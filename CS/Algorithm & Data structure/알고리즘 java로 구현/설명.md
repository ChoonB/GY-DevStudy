# 알고리즘 구현 설명
## A_DP_피보나치
- DP에서 탑다운방식과 바텀업 방식 둘 다 구현
- 탑다운 방식은 저장된 값이 있으면 반환하고 없으면 값을 새로 저장한다.
- 계산 후에 메모이제이션.
- 바텀업 방식은 아래부터 for문으로 값을 쌓아 올라간다.
- 한 번 계산한 값은 저장해 다시 재활용한다.

## 사다리 타기 게임 구현
- 우선 필드로 몇명이 참가하는지, 입력 배열과 결과 배열, 사다리 가로줄(floor) 정보가 필요하다.
- 생성자는 게임 인원수를 넣어 생성하도록 했다.
- 입력값 배열과 결과값 배열은 setter로 등록한다. 참가자 수와 크기에 차이가 있으면 예외처리
- floor는 수동과 random 자동으로 구분했다. 수동은 사다리 범위에 맞게 직접 입력한다.
- 배열의 index가 위에서부터 0으로 시작하는 층수(floor)고, 안의 값이 floor의 위치인데 좌측에서부터 0으로 시작한다.
- 자동은 Math.random()으로 구현.
- 게임은 tmp값을 둬서 floor 배열의 값들을 기준으로 서로 위치를 교환하는 식으로 구현했다. 반환은 이차원 배열로 input과 output 값을 매칭해서 반환.

## 탐색
### 순차탐색
- for문으로 배열 처음부터 끝까지 탐색

### 이진탐색
- 배열의 시작 인덱스를 low, 마지막 인덱스를 high로 설정
- low와 high의 중간 값인 mid를 target과 비교
- 일치하면 mid 반환
- 크면 mid+1로 low 올려서 반복, 작으면 mid-1로 high내려서 반복

## 정렬
### 버블정렬
- 이중 for문으로 밖의 for문은 회차.
- 안의 for문은 실제 비교와 swap 연산을 하도록 한다.
- 앞의 값이 뒤의 값보다 크면 swap한다.

### 개선된 버블정렬
- 한 회차에서 이미 정렬이 다 되어 더이상 swap이 진행되지 않았다면, 이미 정렬이 완료된 것으로 판단해 연산을 줄일 수 있다
- count는 연산 횟수를 세기 위해 만든 변수라 없어도 된다.
- 개선된 버블정렬은 버블정렬보다는 효율적이라고 할 수 있지만, 여전히 시간복잡도가 모든 경우에서 O(n^2)이라 잘 쓰이진 않는다.

### 선택정렬
- 바깥쪽 for문은 비교대상의 인덱스 값.
- 안쪽 for문은 1씩 증가하면서 계속 움직이면서 비교 수행
- min 값을 계속 찾아 안쪽 for문이 끝나면 min값과 i값 swap

### 이중삽입정렬
- 탐색하면서 최소값과 최대값을 동시에 찾는다.
- 그럼 1 회차당 2개의 값을 정렬이 가능해 속도가 더 빨라진다.
- 바깥쪽 for문에서 i는 최소값으로 1씩증가, j는 최대값으로 1씩감소
- 안쪽 for문에서 최소, 최대 값 동시에 찾아 k가 최소면 i, 최대면 j와 스왑
- 단, 스왑 시 j가 최소, i가 최대값이면 위치를 재조정 해줘야 한다.
