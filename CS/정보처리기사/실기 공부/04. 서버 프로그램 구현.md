# 서버 프로그램 구현 - 1
## 소프트웨어 아키텍처
소프트웨어를 구성하는 요소들간의 관계를 표현하는 시스템의 구조 또는 구조체

### 소프트웨어 아키텍쳐 설계의 기본 원리
1. `모듈화` - A
시스템의 기능들을 모듈 단위로 나누어 유지관리, 재사용이 용이하게 하는 것.
모듈 간 `결합도의 최소화`와 모듈 내 `응집도의 최대화`가 목표이다.

2. 추상화
전체적이고 포괄적인 개념을 설계한 후 세분화해 구체화 시켜 나가는 것.
* 종류 : 과정 추상화, 자료 추상화, 제어 추상화

3. 단계적 분해
상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법. 하향식 설계 전략

4. 정보은닉
한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법.
모듈의 독립적 수행이 가능하다. 하나의 모듈이 변경되어도 다른 모듈에 영향을 주지 않는다.

### 협약(Contract)에 의한 설계
컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
* 명세에 포함될 조건 : 선행조건, 결과조건, 불변조건

## 아키텍처 패턴
아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
SW 시스템 구조를 구성하기위한 기본적인 윤곽을 제시.
서브시스템들과 그 역할이 정의되어 있다.

### 레이어패턴
시스템을 계층으로 구분해 구성하는 고전적인 방법의 패턴
하위계층은 상위계층에 대한 서비스 제공자가 되고, 상위계층은 하위계층의 클라이언트가 된다.
마주보는 두 계층사이에서만 상호작용이 이루어진다.

### 클라이언트-서버 패턴
하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

### 파이프-필터 패턴 - B
데이터 스트림 절차의 각 단계를 필터로 캡슐화해 파이프로 전송하는 패턴
**서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복**

### 모델-뷰-컨트롤러(MVC) 패턴
서브 시스템을 모델,뷰,컨트롤러로 구조화하는 패턴
컨트롤러가 사용자의 요청을 받으면 핵심기능과 데이터를 보관하는 모델을 이용해 뷰에 정보를 출력하는 구조.

### 기타 패턴
* 마스터-슬레이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행한다. 막대한 연산이 필요한 작업을 수행하기 위해 여러대의 컴퓨터를 병렬로 연결하고자 하는 상황에 적합하다. `병렬 컴퓨팅 시스템`

* 인터프리터 패턴 : 프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성된 패턴. 번역이나 프로그래밍 언어 개발에 적합. `번역기, 컴파일러, 인터프리터`


***

## 객체지향
소프트웨어의 각 요소를 객체(Object)로 만든 후 객체들을 조립해 SW를 개발하는 기법

### 객체지향의 구성요소
* 객체
데이터(객체가 가지고있는 속성, 상태)와 함수(객체가 수행하는 기능)으로 구성

* 클래스 - B
공통된 속성과 연산을 갖는 객체의 집합.
하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현하며 데이터를 추상화 하는 단위로 사용된다.

* 메시지 - B
객체들 간의 상호작용에 사용되는 수단. 객체의 동작이나 연산을 일으키는 외부의 요구사항.
객체에게 어떤 행위를 하도록 지시하는 명령

### 객체지향의 특징
* 캡슐화 - B
외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부내용을 은닉하는 것.
인터페이스가 단순화되고, 재사용성이 높아지고, 변경 발생시 파급효과가 적고, 정보은닉과 관련있다.

* 상속
상위클래스의 모든 속성과 연산을 하위클래스가 물려받는 것

* 다형성
하나의 메시지를 각각의 객체가 고유한 방법으로 응답하는 것.
상속받은 여러 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질

* 연관성
두 개 이상의 객체들이 상호 참조하는 관계

### 객체지향 설계 원칙 - A
* SRP, 단일책임원칙 : 객체는 단 하나의 책임만 가져야한다.
* OCP, 개방폐쇄원칙 : 기존 코드를 바꾸지않고도 새로운 기능을 추가할 수 있게 설계해야 된다.
* LSP, 리스코프 치환 원칙 : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다.
* ISP, 인터페이스 분리 원칙 : 사용하지 않는 인터페이스와는 영향을 받지 않아야 한다.
* DIP, 의존 역전 원칙 : 의존관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

***

## 객체지향 분석(OOA)
소프트웨어를 개발하기 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석하는 기법

### 객체지향 분석 방법론
* 럼바우 : 분석 활동을 객체모델, 동적모델, 기능모델로 나누어서 수행
* 부치 : 미시,거시적 개발 프로세스를 모두 사용하며 클래스와 객체들을 분석 및 식별해 클래스의 속성과 연산을 정의한다.
* Jacobson : 유스케이스(Use case)를 강조
* `Coad와 Yourdon` 방법 : E-R 다이어그램을 사용해 객체의 행위를 모델링. 
* Wirfs-Brock 방법 : 분석과 설계간 구분이 없다. 

### 럼바우 분석 기법 - A
Rumbaugh. 모든 소프트웨어 구성요소를 그래픽 표기법을 이용해 모델링하는 기법.
객체 모델링 기법(OMT)라고도 한다.
분석활동은 객체모델링 -> 동적모델링 -> 기능모델링 순으로 이루어진다.

#### 객체 모델링(Object Modeling)
= 정보 모델링. 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별 및 객체들간의 관계를 규정해 표시하는 모델링. ex) `ER 다이어그램(ERD)`

#### 동적 모델링(Dynamic Modeling)
상태 다이어그램을 이용해 시간의 흐름에 따른 객체들 간의 제어흐름, 상호작용, 동작 순서 등 동적인 행위를 표현하는 모델링 ex) `상태변화도(STD), 사건추적도`

#### 기능 모델링(Functional Modeling)
다수의 프로세스들 간의 자료흐름을 중심으로 처리 과정을 표현한 모델링
ex) `자료흐름도(DFD)`

***
# 서버 프로그램 구현 - 2
## 모듈
모듈화를 통해 분리된 시스템의 각 기능으로 서브시스템, 작업 단위 등을 의미한다.
소프트웨어 구조를 이루며 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위.
하나 또는 몇개의 논리적인 기능을 수행하기 위한 명령어들의 집합
모듈의 독립성은 결합도, 응집도에 의해 측정된다.

### 결합도
모듈 간 상호 의존하는 정도. 약할수록 좋다.
* 결합도의 종류와 강도(약<--->강)
자료 - 스탬프 - 제어 - 외부 - 공통 - 내용 결합도

### 결합도의 종류 - A
* 자료 결합도(Data Coupling) : 모듈간 인터페이스가 자료 요소로만 구성될 때의 결합

* 스탬프 결합도(Stamp Coupling) : 모듈 간 인터페이스로 배열이나 레코드 등의 자료구조가 전달될 때의 결합도

* 제어 결합도(Control Coupling) : 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도

* 외부 결합도(External Coupling) : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때 결합도

* 공통 결합도(Common Coupling) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때 결합도. 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용해 상호작용할 때의 결합도

* 내용 결합도(Content Coupling) : 한 모듈이 다른 모듈의 내부기능 및 내부 자료를 직접 참조하거나 수정할 때의 결합도.

### 응집도
모듈 내부 요소들이 서로 관련되어 있는 정도. 강할수록 좋다.
* 응집도의 종류와 강도(약<---->강)
우연적 - 논리적 - 시간적 - 절차적 - 교환적 - 순차적 - 기능적 응집도

### 응집도의 종류 - A
* 우연적 응집도(Coincidental Cohesion) : 모듈 내부의 각 구성요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

* 논리적 응집도(Logical Coheshion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

* 시간적 응집도(Temporal Cohesion) : 특정 시간에 처리되는 몇개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

* 절차적 응집도(Procedural Cohesion) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도

* 교환적 응집도(Communication Cohesion) : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

* 순차적 응집도(Sequential Cohesion) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도

* 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

### 팬인 / 팬아웃 - A	
* 팬인(Fan-In) : 어떤 모듈을 제어하는 모듈의 수. 화살표로 들어오는 수(부모 수)

* 팬아웃(Fan-Out) : 어떤 모듈에 의해 제어되는 모듈의 수. 화살표로 내보내는 수(자식 수)

### N-S 차트
논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법. Chapin Chart라고도 한다.
연속, 선택, 다중선택, 반복 등의 제어 논리 구조로 표현한다.

### 단위 모듈
소프트웨어 구현에 필요한 여러 동작 중 한가지 동작을 수행하는 기능을 모듈로 구현한 것
독립된 컴파일이 가능하며 다른 모듈에 호출이나 삽입되기도 한다.

***

### IPC - A
모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
대표적인 메서드는 Shared Memory(공유 메모리), Socket(소켓), Semaphores(세마포어), Message Queueing(메시지 큐잉), Pipes & named Pipes(파이프와 네임드 파이프)이 있다.

### 테스트 케이스 - A
구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서
#### 표준에 따른 테스트 케이스의 구성요소
* 식별자 : 항목 식별자, 일련번호
* 테스트 항목 : 테스트 대상
* 입력 명세 : 테스트 데이터 또는 테스트 조건
* 출력 명세 : 테스트 케이스 수행 시 예상되는 출력 결과
* 환경 설정 : 필요한 하드웨어나 소프트웨어 환경
* 특수 절차 요구 : 테스트 케이스 수행 시 특별히 요구되는 절차
* 의존성 기술 : 테스트 케이스 간의 의존성

### 공통 모듈 명세 기법의 원칙
공통모듈 : 여러 프로그램에서 공통으로 사용할 수 있는 모듈. 명확히 이해할 수 있도록 다음과 같은 명세 기법을 준수해야 한다.
* 정확성(Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함
* 명확성(Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확히 작성함
* 완전성(Completeness) : 시스템 구현을 위해 필요한 모든 것을 기술함
* 일관성(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성함
* 추적성(Traceability) : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함

### 재사용
이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화 하는 작업
#### 재사용 규모에 따른 분류
* 함수와 객체 : 클래스와 메소드 단위의 소스코드를 재사용함
* 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
* 애플리케이션 : 공통된 기능을 제공하는 애플리케이션을 공유하는 방식으로 재사용

***

# 서버 프로그램 구현 - 3
## 코드
자료의 분류, 조합, 집계, 추출을 용이하기 위해 사용하는 기호

### 코드의 주요 기능
* 식별 : 데이터간 성격에 따라 구분 가능함
* 분류 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음
* 배열 : 의미를 부여해 나열할 수 있음
* 표준화 : 다양한 데이터를 기준에 맞춰 표현할 수 있음
* 간소화 : 복잡한 데이터를 간소화할 수 있음

### 코드의 종류
* 순차 코드(Sequential Code) - B
자료의 발생 순서, 크기 순서 등 일정 기준에 따라 최초의 자료부터 차례로 일련 번호를 부여하는 방법. 순차코드 혹은 일련번호 코드라고도 한다.
ex) 1,2,3,4,...

* 블록 코드(Block Code)
코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로 구분코드라고도 한다.
ex) 1001~1100 : 총무부, 1101~1200 : 연구부

* 10진코드(Decimal Code)
코드화 대상 항목을 0~9까지 10진 분할하고 다시 그 각각에 대해 10진 분할을 필요한 만큼 반복하는 방법으로 도서관 코드라고도 한다.
ex) 1000 : 공학, 1100 : SW 공학, 1110: SW 설계

* 그룹 분류 코드(Group Classification Code)
코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고 각 그룹안에서 일련 번호를 부여하는 방법
ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계

* 연상코드(Mnemonic Code)
코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용해 코드를 부여하는 방법
ex) TV-40 : 40인치 tv, L-15-220: 15v 220w 전구

* 표의 숫자 코드(Significant Digit Code) - B
코드화 대상 항목의 성질(길이,넓이,지름,폭 등)같은 물리적 수치를 코드에 적용하는 방법. 유효 숫자코드라고도 한다.
ex) 120-720-1500 : 두께x폭x길이가 이 사이즈인 합판

* 합성 코드(Combined Code)
필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코들르 조합해 만드는 방법
ex) 연상코드 + 순차코드

***
## 디자인 패턴 - A
모듈 간 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제
GOF 디자인 패턴은 생성, 구조, 행위 패턴으로 구분된다.

### 생성 패턴 - A
클래스나 객체의 생성과 참조 과정을 정의하는 패턴

* 추상 팩토리(Abstract Factory)
구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴
연관된 서브 클래스를 묶어 한번에 교체하는 것이 가능하다.

* 빌더(Builder)
작게 분리된 인스턴스를 건축하듯이 조합해 객체를 생성하는 패턴
객체의 생성 과정과 표현 방법을 분리하고 있어 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.

* 팩토리 메서드(Factory Method)
객체 생성을 서브 클래스에서 처리하도록 분리해 캡슐화한 패턴
상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
가상 생성자(Virtual Constructor) 패턴이라고도 한다.

* 프로토타입(Prototype)
원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
일반적인 방법으로 객체를 생성하며 비용이 큰 경우 주로 이용한다.

* 싱글톤(Singleton)
하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없는 패턴
클래스 내에서 인스턴스가 하나뿐임을 보장하며 불필요한 메모리 낭비를 최소화할 수 있다.

### 구조 패턴 - A
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체를 조합해 더 큰 구조로 만드는 패턴

* 어댑터(Adapter)
호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
기존의 클래스들을 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

* 브리지(Bridge)
구현부에서 추상층을 분리해 서로가 독립적으로 확장할 수 있도록 구성한 패턴
기능과 구현을 두 개의 별도 클래스로 구현

* 컴포지트(Composite)
여러 객체를 가진 복합객체와 단일객체를 구분없이 다루고자 할 때 사용하는 패턴
객체들을 트리구조로 구성해 복합객체 안에 복합객체가 포함되는 구조를 구현할 수 있다.

* 데코레이터(Decorator)
객체 간 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

* 퍼싸드(Facade)
복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다.

* 플라이웨이트(Flyweight)
인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 공유해 사용함으로써 메모리를 절약하는 패턴
다수의 유사 객체를 생성하거나 조작할 때 유용하다.

* 프록시(Proxy)
복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하는 패턴. 대리자라고도 한다.
내부에서는 객체 간 복잡한 관계를 단순하게 정리해주고, 외부에서는 객체의 세부적인 내용을 숨겨주는 역할을 한다.

### 행위 패턴 - A
클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

* 책임 연쇄(Chain of Responsibility)
요청을 처리할 수 있는 객체가 둘 이상 존재해 한 객체가 처리 못하면 다음 객체로 넘어가는 패턴. 이 객체들 끼리는 고리(Chain)으로 엮여 고리를 따라 책임이 넘어간다.

* 커맨드(Command)
요청을 객체의 형태로 캡슐화해 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그를 남기는 패턴
요청에 사용되는 각종 명령어들을 추상클래스와 구체 클래스로 분리해 단순화한다.

* 인터프리터(Interpreter)
언어에 문법 표현을 정의하는 패턴. SQL이나 통신 프로토콜 개발에 사용된다.

* 반복자(Iterator)
자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
내부 표현 방법의 노출 없이 순차적인 접근이 가능하다.

* 중재자(Mediator)
수많은 객체들 간의 복잡한 상호작용을 캡슐화해 객체로 정의하는 패턴
객체간 의존성을 줄여 결합도를 감소할 수 있다.

* 메멘토(Memento)
특정 시점에서 객체 내부 상테를 객체화해 요청에따라 해당 시점의 상태로 돌릴 수있는 기능을 제공하는 패턴. ctrl+z 같은 되돌리기 기능 개발시 사용

* 옵저버(Observer)
한 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에게 상태를 전달하는 패턴
일대다 의존성을 정의. 주로 분산 시스템에서 이벤트 생성, 발행, 수신 시 사용

* 상태(State)
객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용
객체의 상태를 캡슐화하고 이를 참조하는 방식으로 처리

* 전략(Strategy)
동일한 계열의 알고리즘들을 개별적으로 캡슐화해 상호 교환할 수 있도록 정의하는 패턴
클라이언트는 독립적으로 원하는 알고리즘을 선택하고 변경할 수 있다.

* 템플릿 메소드(Templete Method)
상위 클래스에서 골격을 정의하고 하위 클래스에서 세부 처리를 구조화 하는 패턴
유사한 서브 클래스를 묶어 공통 내용을 상위 클래스에서 정의함으로써 유지보수 용이하게 해준다.

* 방문자(Visitor)
각 클래스들의 데이터 구조에서 처리 기능을 분리해 별도의 클래스로 구성하는 패턴
분리된 처리기능은 각 클래스를 방문하여 수행.

***

### crontab 명령어 작성 방법
분 시 일 월 요일 명령어

요일은 0이 일요일 6이 토요일. *는 매 시기마다 수행.
*/15 : 15분마다 수행.