# 알고리즘 구현 설명
## A_DP_피보나치
- DP에서 탑다운방식과 바텀업 방식 둘 다 구현
- 탑다운 방식은 저장된 값이 있으면 반환하고 없으면 값을 새로 저장한다.
- 계산 후에 메모이제이션.
- 바텀업 방식은 아래부터 for문으로 값을 쌓아 올라간다.
- 한 번 계산한 값은 저장해 다시 재활용한다.

## 사다리 타기 게임 구현
- 우선 필드로 몇명이 참가하는지, 입력 배열과 결과 배열, 사다리 가로줄(floor) 정보가 필요하다.
- 생성자는 게임 인원수를 넣어 생성하도록 했다.
- 입력값 배열과 결과값 배열은 setter로 등록한다. 참가자 수와 크기에 차이가 있으면 예외처리
- floor는 수동과 random 자동으로 구분했다. 수동은 사다리 범위에 맞게 직접 입력한다.
- 배열의 index가 위에서부터 0으로 시작하는 층수(floor)고, 안의 값이 floor의 위치인데 좌측에서부터 0으로 시작한다.
- 자동은 Math.random()으로 구현.
- 게임은 tmp값을 둬서 floor 배열의 값들을 기준으로 서로 위치를 교환하는 식으로 구현했다. 반환은 이차원 배열로 input과 output 값을 매칭해서 반환.

## 탐색
### 순차탐색
- for문으로 배열 처음부터 끝까지 탐색

### 이진탐색
- 배열의 시작 인덱스를 low, 마지막 인덱스를 high로 설정
- low와 high의 중간 값인 mid를 target과 비교
- 일치하면 mid 반환
- 크면 mid+1로 low 올려서 반복, 작으면 mid-1로 high내려서 반복

## 정렬
### 버블정렬
- 이중 for문으로 밖의 for문은 회차.
- 안의 for문은 실제 비교와 swap 연산을 하도록 한다.
- 앞의 값이 뒤의 값보다 크면 swap한다.

### 개선된 버블정렬
- 한 회차에서 이미 정렬이 다 되어 더이상 swap이 진행되지 않았다면, 이미 정렬이 완료된 것으로 판단해 연산을 줄일 수 있다
- count는 연산 횟수를 세기 위해 만든 변수라 없어도 된다.
- 개선된 버블정렬은 버블정렬보다는 효율적이라고 할 수 있지만, 여전히 시간복잡도가 모든 경우에서 O(n^2)이라 잘 쓰이진 않는다.

### 선택정렬
- 바깥쪽 for문은 비교대상의 인덱스 값.
- 안쪽 for문은 1씩 증가하면서 계속 움직이면서 비교 수행
- min 값을 계속 찾아 안쪽 for문이 끝나면 min값과 i값 swap

### 이중삽입정렬
- 탐색하면서 최소값과 최대값을 동시에 찾는다.
- 그럼 1 회차당 2개의 값을 정렬이 가능해 속도가 더 빨라진다.
- 바깥쪽 for문에서 i는 최소값으로 1씩증가, j는 최대값으로 1씩감소
- 안쪽 for문에서 최소, 최대 값 동시에 찾아 k가 최소면 i, 최대면 j와 스왑
- 단, 스왑 시 j가 최소, i가 최대값이면 위치를 재조정 해줘야 한다.

### 삽입정렬
- 두번째 원소부터 시작한다.(첫 원소는 이미 정렬되어있다고 가정)
- 현재 원소를 key로 선택하고, 앞의 원소들과 비교해 삽입할 위치를 찾는다.
- Key보다 작은 값을 만나거나 배열의 시작에 도달하면 반복을 멈춘다. 해당 위치에 key값을 삽입한다.
- 배열의 모든 원소가 정렬될 때까지 반복한다
- 밖의 for문으로 두번째 값부터 key값을 삼아서 앞의 원소와 비교를 시작한다.
- 안쪽의 while문으로 key값이 이전 원소들보다 작을 때까지만 원소를 한칸씩 뒤로 미루고, 적합한 위치에 key값을 삽입한다.

### 이진삽입정렬
- key값 앞에 있는 배열의 값들은 이미 정렬된 상태이다.
- 그래서 비교를 할 때 순차탐색으로 n번씩 비교하는 것 보다, 이진탐색을 활용해 탐색 횟수를 줄일 수 있다.
- high low mid를 만들어 이진탐색으로 비교하는과정을 만들었다.
- 비교 횟수는 줄어들었다.
- 하지만 시간복잡도는 여전히 O(n^2)으로 일반 삽입정렬과 동일하다.

### 힙정렬
- 오름차순 기준
- 먼저 주어진 배열을 최대힙이 만족하도록 만드는 데 이 과정을 Heapify라 한다.
- 최대힙의 루트노드에 있는 가장 큰 값을 배열의 맨 뒤로 보내고, 그 원소를 제외한 나머지 배열의 원소를 다시 최대힙을 만족하도록 재구성한다.
- 이 과정을 반복해 맨 뒤에 가장 큰값이 가도록해서 오름차순으로 정렬한다.

### 퀵정렬
- 배열 안의 한 요소를 pivot(피벗)으로 선택한다.
- pivot을 기준으로 작은 요소는 모두 왼쪽으로, 큰 요소는 오른쪽으로 옮긴다.
- pivot을 제외한 왼쪽 배열과 오른쪽 배열을 부분배열로 나눠서 그 안에서 pivot을 새로 정해 정렬한다.
- 재귀를 사용해 부분배열이 더이상 분할되지 않을 때까지 반복한다.
- 재귀 호출 한번에 최소 하나의 원소(피벗)은 최종 위치가 정해진다.
- 가운데 값을 pivot으로 정하고 작은 값은 왼쪽, 큰값은 오른쪽으로 스왑해 pivot을 기준으로 정렬한다. 그리고 pivot을 제외한 좌 우 부분배열을 다시 재귀적으로 정렬한다.
